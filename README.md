# 志愿者排表系统

## 项目简介

这是一个用于志愿者活动管理的全流程自动化排表系统，专为马拉松等大型志愿者活动设计。系统能够处理从志愿者招募、面试筛选到最终排班的完整流程，支持多种志愿者类型和复杂的人员绑定关系。

## 核心功能

### 🔧 通用工具模块

- Excel文件合并、排序、去重、拆分
- 字段提取、表格对比、多表查重
- 支持命令行独立使用

### 📝 面试结果收集模块

- 自动汇总多个面试官的打分表
- 智能分离已面试和未面试人员
- 成绩排序和数据清理

### 📊 排表模块（开发中）

- 智能小组划分和组长分配
- 复杂绑定关系处理（情侣、家属、团体）
- 多种志愿者类型支持
- 自动化排班算法

## 快速开始

### 环境要求

- Python 3.8+
- 依赖库见 `requirements.txt`

### 安装使用

```bash
# 1. 安装依赖
pip install -r requirements.txt

# 2. 初始化项目
make setup

# 3. 准备输入文件（见使用说明）

# 4. 运行系统
python main.py --all
```

## 工作流程概览

1. **志愿者招募**：我们会通过问卷的方式招募志愿者，问卷会收集志愿者的基本信息、可参与的时间段、技能特长等。问卷数据会被导出为Excel表格，包含所有志愿者的报名信息。且志愿者的来源有多种。
2. **面试**：普通志愿者报名后，我们会安排面试官对志愿者进行面试，每个面试官在面试的时候会有一张统一的志愿者面试打分表，面试官会根据志愿者的表现进行打分，打分表会记录志愿者的基本信息和面试评分。每一张表会有一列是“归一化成绩”。但因为面试场次众多，每一场面试又有很多面试官，所以这一阶段结束后会有很多张打分表需要进行汇总和排序。我们需要将所有这些打分表整合到一个统一的表格中，并根据“归一化成绩”进行排序，以便我们能够快速筛选出表现优异的志愿者。另外可能还有“小闪电”和“摄影志愿者”的得分，这两个分数也需要被保留在最终的统一打分表中，但排序时只根据“归一化成绩”进行排序，其他两个得分字段不参与排序。

   > 同时要注意：汇总出来的统一打分表中的人员需要全部包含在最初的普通志愿者招募表中，不能出现未报名的人员。对于招募表中有但打分表中没有的人员，表明他们没有参加面试，需要单独列出未面试人员名单，方便后续的管理和跟进。对于参加面试的人员组成的集合（也就是在面试打分表中出现过的人组成的集合），我们称为“普通志愿者表”，用于后续的排表流程。
   >
3. **排表**：在志愿者通过面试后，我们需要根据活动主办方给的岗位表对所有志愿者进行排表。岗位表会列出所有需要的岗位信息及其对应的人数要求。我们需要将通过面试的志愿者按照岗位需求进行分配，确保每个岗位都有足够的志愿者。具体的细节会在下面详细说明。

## 志愿者种类和构成

### 志愿者人员来源及构成

- **普通志愿者**：通过报名问卷和面试筛选出来的志愿者。
- **内部志愿者**：组织内部的志愿者，不用经过面试。
- **家属志愿者**：内部志愿者每个人最多可以带两个家属志愿者参与活动，这些家属志愿者也不需要经过面试。
- **团体志愿者**：一些别的组织或学校派来的志愿者团队，这些志愿者也不需要经过面试。

> 注意：上面这四种志愿者种类是志愿者唯一的四种来源，换句话说志愿者有且仅有上面的这四种属性，且是**互斥**的关系，即每一个志愿者只能属于其中的一种属性（种类）。
> 这四种志愿者的人数总和就是我们这次活动报名的志愿者总人数。也就是需要参与到最终排表中的志愿者总人数。一般来说，志愿者总人数会大于等于岗位需求人数，多出来的志愿者会被划分为储备志愿者。
> 这里提到的“普通志愿者”只是参与面试的面试者，涵盖正式普通志愿者和储备志愿者两种，未面试人员不属于普通志愿者的范畴。

### 特殊志愿者种类

上面的四种志愿者种类是志愿者的唯一来源，这里的特殊志愿者只是一种特殊的额外身份，在排表时可能需要格外关注。但是他们各自的属性值仍然是上面四种志愿者种类中的一种。

- **组长志愿者**：只在内部志愿者中产生，一部分内部志愿者会主动报名成为组长志愿者。
- **情侣志愿者**：需要另外填写单独的情侣志愿者报名问卷，问卷中需要填写情侣两个人的姓名和学号，排表时需要安排在同一岗位工作。情侣两个人可以是普通志愿者、内部志愿者、家属志愿者或团体志愿者中的任意一种组合，即两人属性可以相同也可以不同。
- **摄影志愿者**：只在正式普通志愿者中产生，需要经过面试筛选。
- **“小闪电”志愿者**：实际上就是副组长志愿者，只在正式普通志愿者中产生，需要经过面试筛选。
- **储备志愿者**：只在普通志愿者中产生，当所有岗位的志愿者人数都满足要求后，剩余的普通志愿者会被划分为储备志愿者，储备志愿者不参与排表。但会单独列出储备志愿者名单，方便后续的管理和跟进。换言之，非正式普通志愿者即为储备志愿者。

> 注意：上面这五种特殊志愿者身份并不是互斥的关系，即一个志愿者可以同时拥有多种特殊身份，比如一个普通志愿者同时是情侣志愿者和摄影志愿者。但是只能有一个属性值，比如一个志愿者只能是普通志愿者，不能同时是普通志愿者和内部志愿者。

## 输入表格详解

我们在系统中会使用到多个Excel表格文件，每个表格文件中会包含多个字段值，不同的表格文件中会有一些相同的字段值，也会有一些不同的字段值。下面我们来详细讲解说明每个表格文件中的字段值。

### 通用字段值

所有志愿者的表格中都会包含以下字段值，这是每个志愿者的基本信息：

- 学号
- 姓名
- 姓名拼音
- 性别
- 证件类型
- 证件号
- 出生日期
- 学院
- 身高
- 邮箱
- 手机号
- QQ号
- 微信号
- 政治面貌
- 马拉松次数
- 校区
- 宿舍楼栋（闵行）
- 宿舍楼栋（非闵行）
- 衣服尺码

> 注意：以上字段值在所有志愿者的表格中都是必须包含的，但并不是表头的顺序和命名在所有表格中都是一致的，但是表头名字中一定包含以上字段值的关键词。比如“学号”字段在某些表格中可能被命名为“我的学号”，但只要表头中包含“学号”这个关键词，我们就能识别出这是学号字段。

其中主键是 **“学号”**，即每个志愿者的学号是唯一的，不会重复。他能够唯一标识一个志愿者。第二主键是 **“姓名”**，除非出现同名同姓的情况（小概率），否则姓名也可以标识一个志愿者的。

### 普通志愿者招募表

普通志愿者招募表是我们通过问卷收集到的志愿者报名信息，包含所有报名的普通志愿者的基本信息。这个表格会作为后续面试和排表的基础数据来源之一。表头中除了包含通用字段值外，还会包含以下比较有用的字段值：

- 其他工作：一共有三个选项，分别是“摄影志愿者”、“小闪电”和“无”。

> 注意：普通志愿者招募表并不直接参与到后续排表流程。因为普通志愿者招募表中可能包含一些未参加面试的人员，这些人员的信息需要单独列出，方便后续的管理和跟进。参加面试的人员组成的集合，称为“普通志愿者表”，用于后续的排表流程。

### 内部志愿者表

内部志愿者表是我们组织内部的志愿者名单，这些志愿者不需要经过面试，直接参与排表。表头中除了包含通用字段值外，还会包含以下比较有用的字段值：

- 是否以小组长或者区长的身份参加本次活动：一共有三个选项，分别是“小组长”、“区长”和“无”。

### 家属志愿者表

家属志愿者表是内部志愿者带来的家属名单，这些志愿者不需要经过面试，直接参与排表。表头中除了包含通用字段值外，还会包含以下比较有用的字段值：

- 你是谁的家属：填写内部志愿者的姓名。
- 活动中是否希望与他/她同组：“是”或“否”。

### 团体志愿者表

团体志愿者表是一些别的组织或学校派来的志愿者名单，这些志愿者不需要经过面试，直接参与排表。每个团体都有一张单独的表格文件，他们统一安放在“输入数据/团体”这个文件夹下。表头中只需要关注通用字段值，没有其他特殊字段值。

> 注意：每个团体的表格文件的命名格式为“<团体名称>.xlsx”的形式，比如“计算机学院团委.xlsx”。

### 情侣志愿者表

情侣志愿者表是报名参加情侣志愿者的名单，这些志愿者需要在排表时安排在同一岗位工作。表头中只需关注以下字段值：

- 情侣一学号
- 情侣一姓名
- 情侣二学号
- 情侣二姓名

### 面试打分表

面试打分表是面试官对普通志愿者进行面试打分后生成的表格文件，每个面试官会有一张单独的表格文件，这些表格文件会被统一安放在“输入数据/面试打分表”这个文件夹下。表头中没有通用字段值，只需关注以下字段值：

- 姓名
- 学号
- 归一化成绩
- 小闪电得分：对于没有报名“小闪电”的志愿者，这个值为空。
- 摄影得分：对于没有报名“摄影志愿者”的志愿者，这个值为空。

> 注意：在最终汇总的统一面试打分表中，这五个字段也都要有，且排序时只根据“归一化成绩”进行排序，其他两个得分字段不参与排序。

### 岗位表

岗位表是活动主办方提供的岗位需求表格，列出了所有需要的岗位及其对应的时间段和人数要求。表头中只需关注以下字段值：

- 岗位名称
- 岗位简介
- 需求人数

### 直接委派名单

名单上的志愿者可以是任何属性（正式普通志愿者、内部志愿者、家属志愿者或团体志愿者），他们会被直接分配到指定小组工作（后续排表会用到）。表格中只有三列字段值：

- 学号
- 姓名
- 小组号

## 排表规则

最终的排表结果会生成一个统一的排班表格，称为“总表”，包含所有志愿者的排班信息。总表表格中会包含以下字段值：

- 小组号
- 岗位名称
- 岗位简介
- 小组长（的姓名）
- 学号
- 姓名
- 姓名拼音
- 性别
- 证件类型
- 证件号
- 出生日期
- 学院
- 身高
- 邮箱
- 手机号
- QQ号
- 微信号
- 政治面貌
- 马拉松次数
- 校区
- 宿舍楼栋
- 衣服尺码

其中前四列是小组相关的信息，后面的字段是志愿者的基本信息。每一行数据代表一个志愿者的排班信息。且根据志愿者的属性和身份的不同，属于他的那一行表格数据的背景颜色也会不同。

---

在排表中有很多流程、环节和规则，下面我们来详细说明每个环节的具体操作和注意要点。

### 排表总体流程

1.**小组划分和组长分配**：根据岗位需求和内部志愿者报名组长的人数，划分出总表的小组，这是排表的第一步，也是搭建总表的框架。有下面的规则：

- 一般来说，每个小组只属于一种岗位，但同一个岗位可以有多个小组。
- 每个小组需要有一个组长，组长从报名的内部志愿者中分配。尽量保证每个报名的内部志愿者都能当上组长。
- 这里有一个分配算法示例：
  ```python
  def split_volunteers(岗位需求列表, 小组数量, 最小独立小组阈值=0.5):
    """
    将多个岗位的志愿者需求拆分成指定数量的小组，使各小组人数尽量均衡。
    特别处理人数过少的岗位，使其独立成组。

    参数:
        岗位需求列表 (list): 每个元素代表一个岗位需要的志愿者人数。
        小组数量 (int): 总共需要分成的小组数。
        最小独立小组阈值 (float, optional): 用于判断岗位是否应独立成组的阈值。
            当岗位人数 < 理想小组人数 * 阈值 时，独立成组。
            默认为 0.5 (可根据需要手动调整)。

    返回:
        list: 每个元素是一个列表，代表对应岗位拆分后的小组人数。
    """
  ```

  * 输入校验与基础计算
    - 先检查输入是否有效（岗位列表非空、小组数量为正），无效则直接返回空结果。
    - 计算所有岗位的总需求人数，再根据总人数和目标小组数，算出 “初步理想小组人数”（用于判断哪些岗位需要独立成组）。
  * 识别并处理独立小组
    - 遍历每个岗位，若岗位人数大于 0，且不超过 “初步理想小组人数 × 阈值”（默认 0.5），则该岗位直接独立成组（一个岗位对应一个小组）。
    - 记录已分配的独立小组数量，若已占满目标小组数，直接返回结果。
  * 为剩余岗位分配小组数量
    - 收集未独立成组且有需求的岗位，计算剩余可分配的小组数和这些岗位的总需求人数。
    - 按每个岗位人数占剩余总人数的比例，估算该岗位应分配的小组数，确保每个岗位至少 1 个小组。
    - 调整小组数量，确保所有剩余岗位分配的小组数总和等于剩余可分配小组数。
  * 拆分岗位人数到小组
    - 对每个需拆分的岗位，用 “总人数 ÷ 小组数” 得到基础人数，剩余人数平均分配给前几个小组（前 N 个小组多 1 人）。
    - 将拆分后的小组人数填入结果列表，最终返回完整分组结果。

1. **拆分普通志愿者表（确定正式普通志愿者和储备志愿者表）**：这时候一共需要的志愿者人数已经确定了，就是岗位表中所有岗位的需求人数之和，记为 N 。总人数减去内部志愿者、家属志愿者、所有团体志愿者的人数，剩下的就是需要从普通志愿者中分配的人数，记为 M 。

- 根据普通志愿者的最终面试汇总表，按照归一化成绩将 `普通志愿者表`拆成两张表：一张是需要分配的"正式普通志愿者表"（前 M 名），另一张是"储备志愿者表"（后面的人员）。储备志愿者表单独列出，且按照归一化成绩从高到低排列，方便后续管理和跟进。（注意：拆分的这两张新表中要包含通用字段）。
- 检查一下各个绑定集合，剔除掉绑定集合元素中的储备志愿者，剔除后如果只剩下一个元素，则说明这个绑定集合无法满足，该绑定集合作废。比如绑定集合{A，B}，如果检查出来A是储备志愿者，那么这个绑定集合就作废了，因为B一个人无法满足绑定要求;如果绑定集合{C，D，E}，检查出来D是储备志愿者，那么这个绑定集合就变成了{C，E}，仍然有效。
  > - 注意这里面名字的差别：这里操作的是“普通志愿者表”，而不是“普通志愿者招募表”，因为只有“普通志愿者表”中的人员才是通过面试的，才有资格被分配到岗位中去。而正式普通志愿者表和储备志愿者表都是从“普通志愿者表”中拆分出来的。
  > - 普通志愿者招募表 = 普通志愿者表 + 未面试人员名单。
  > - 普通志愿者表 = 正式普通志愿者表 + 储备志愿者表。
  >

3. **人员绑定**：将有特殊身份的志愿者进行绑定，确保他们在排表时能够被正确分配到相同的小组中，每个绑定集合至少有两个人。这里有下面几种绑定关系：

   - 情侣志愿者绑定：根据情侣志愿者表，将报名的情侣志愿者进行绑定，确保他们在排表时被安排在同一小组工作。
   - 家属志愿者绑定：根据家属志愿者表，如果家属志愿者希望和对应的内部志愿者同组工作（即家属志愿者“是否希望与他/她同组”这一项选择“是”），则将他们进行绑定，确保他们在排表时被安排在同一小组工作。如果家属志愿者“是否希望与他/她同组”这一项选择“否”，则不做绑定，当成落单的家属志愿者参与后续分配。

     > 在绑定家属的过程中，有可能出现家属志愿者“是否希望与他/她同组”这一项选择“是”，但是对应的姓名并没有出现在内部志愿者表中的情况。对于这种情况，我们直接认为绑定失败，不进行绑定处理，家属志愿者作为落单的家属志愿者进行后续分配。(等价于“活动中是否希望与他/她同组”选择“否”的情况)
     >
   - 团体志愿者绑定：根据团体志愿者表，将同一团体的志愿者进行绑定，确保他们在排表时被安排在同一小组工作。

   > 注意：有可能会出现**绑定元素重合**的情况。比如有三个绑定集合分别是{A，B}，{B，C，D}和{D，E，F}，那么最终的绑定集合就是{A，B，C，D，E，F}。在排表时，同一个绑定集合的志愿者需要被安排在同一小组工作。
   > 绑定集合生成之后，可以人工查看和调整，确保绑定关系合理。后面的排表流程会基于这个绑定集合进行。
   > 所有绑定集合生成后，我们要检查集合中的元素有没有出现在直接委派名单中，集合中只要有一个元素要委派到指定小组，那么整个集合都要被委派到该小组。所以不允许出现同一个绑定集合中的不同元素被委派到不同小组的情况。如果出现这种冲突情况，要及时报错并人工处理。
   >
4. **志愿者分配**：根据岗位需求和志愿者的属性，将志愿者分配到各个小组中。只要的分配原则有两个：“先直接委派再自由分配”和“先分配整体再分配个体”。具体的流程见下：

   - 搭好总表框架并插入小组相关数据：首先先通过步骤一中的小组划分和组长分配，搭建好总表的框架。填好总表的前四列（小组号、岗位名称、岗位简介、小组长），后面就只需要填志愿者的基本信息列。每个小组的第一行数据一定填写的是组长的信息。
   - 插入组长相关人员：寻找包含组长的绑定集合，将绑定集合中的所有志愿者都分配到该组长所在的小组中，确保绑定关系被满足。
   - 插入绑定集合：将绑定集合依次插入到各个小组中，确保绑定关系被满足（插入时先检查该绑定集合是不是已经被直接委派到指定小组了，如果有，就直接分配到目的小组；如果没有，就自由分配）。且在插入时要考虑小组剩余人数，确保不会超出岗位需求人数。元素个数多的绑定集合要优先，且最好插入小组人数多的小组，避免后续插入时因为小组剩余人数不足而无法插入。
   - 插入直接委派名单：根据直接委派名单，现在剩下的人都是落单的志愿者（不在任何绑定集合中），将这些志愿者直接分配到指定小组中，确保直接委派关系被满足。（插入时要考虑小组剩余人数，确保不会超出岗位需求人数）

   > 截止到这一步，我们完成了所有直接委派分配和绑定集合分配，且所有的组长和绑定关系都被满足了。接下来我们需要插入剩下落单的内部志愿者、家属志愿者和正式普通志愿者。
   >

   - 插入剩下落单的内部志愿者和家属志愿者：依次均匀插入到各个小组中，确保他们被分配到合适的小组中。插入时要考虑小组剩余人数，确保不会超出岗位需求人数。

   > 这一步完成之后，只剩下落单的正式普通志愿者需要分配。
   >

   - 检查现在每个小组中是否都有“小闪电”和“摄影志愿者”: 在前面的流程中，可能每个小组现在已经被插入了很多志愿者，这些志愿者中如果有人有“小闪电”/“摄影志愿者”的身份，那么证明他所在的小组已经有了“小闪电”/“摄影志愿者”，不需要再有“小闪电”/“摄影志愿者”了。如果没有，则需要从剩下的正式普通志愿者中挑选一个报名参加“小闪电”/“摄影志愿者”的志愿者插入到该小组中，确保每个小组都有“小闪电”/“摄影志愿者”，要结合面试最终汇总表，优先插入“小闪电”归一化成绩/“摄影志愿者”得分高的志愿者。

   > 注意：在针对每一小组检查“小闪电”志愿者和“摄影志愿者”时，如果一个组中已经有了多个“小闪电”或“摄影志愿者”，选择一个就好。但这种情况一般不会出现。
   >

   - 插入剩下的正式普通志愿者：将剩下的正式普通志愿者依次均匀插入到各个小组中，确保所有岗位的需求人数都被满足。按照之前的计算，人数是正好的，不会出现多余或不足的情况。

截止到这一步，总表已经成功排出来了，所有岗位的需求人数都被满足，且所有绑定关系都被满足。

## 系统模块设计

为了实现上述工作流程，我们设计了以下几个主要模块，每个模块下有很多程序文件，负责不同的功能。

### 通用工具模块

可以脱离于具体的业务流程，单独使用的一些通用工具程序，主要用于Excel表格的处理和操作。可有被下面的业务模块调用。

#### 程序一：多表格查重程序

- 输入：多个Excel文件和需要查重的字段值列表。
- 输出：查重结果报告/日志文件和重复记录的Excel文件。
- 功能：读取多个Excel文件，针对指定的字段值进行查重，找出重复的记录，并生成查重结果报告，报告中包含重复记录的详细信息和所在文件位置，以及一个新的Excel文件，包含所有重复的记录。

> 举例：同时读取“普通志愿者招募表.xlsx”，“内部志愿者表.xlsx”，“家属志愿者.xlsx”和所有的“<团体名称>.xlsx”，针对“学号”和“姓名”字段进行查重，找出多个表格中这两个字段值均重复的记录，并生成查重结果报告，包含重复学号和姓名的详情信息以及所有重复的文件信息。

#### 程序二：表格对比及拆分程序

- 输入：两个Execl表格，第一个表格是主表格，第二个表格是用于对比的表格，我们称为“对比表格”;指定的字段值。
- 输出：主表格中包含在对比表格中的行的Excel文件和主表格中不包含在对比表格中的行的Excel文件。
- 功能：指定对比表格中的某一个字段值（比如“学号”），将主表格中的该字段值和对比表格中的该字段值进行对比，找出主表格中包含在对比表格中的行，和主表格中不包含在对比表格中的行，分别生成两个新的Excel文件。

> 举例：将“普通志愿者招募表.xlsx”作为主表格，将统一的面试打分表作为对比表格，指定“学号”字段进行对比，生成两个新的Excel文件：一个是包含在统一面试打分表中的普通志愿者名单，另一个是不包含在统一面试打分表中的未面试人员名单。

#### 程序三：表格字段值提取程序

- 输入：一个Excel文件，需要提取的字段值列表或者不需要提取的字段值列表
- 输出：包含指定字段值的Excel文件(或者不包含指定字段值的Excel文件)。
- 功能：根据输入的需要提取的字段值列表，从输入的Excel文件中提取出这些字段值，生成一个新的Excel文件，包含提取出的字段值。

> 举例：读取“面试打分表.xlsx”，提取“姓名”，“学号”，“归一化成绩”，“小闪电得分”和“摄影得分”这五个字段值，生成一个新的Excel文件，包含这五个字段值。

#### 程序四：表格字段值排除程序

- 输入：一个Excel文件，需要除去的字段值列表
- 输出：不包含指定字段值的Excel文件
- 功能：根据输入的需要除去的字段值列表，从输入的Excel文件中除去这些字段值，生成一个新的Excel文件，包含剩下的字段值。

> 举例：读取“普通志愿者招募表.xlsx”，除去“证件类型”，“证件号”这些字段值，生成一个新的Excel文件，包含剩下的字段值。

#### 程序五：表格排序程序

- 输入：一个Excel文件和需要排序的字段值。
- 输出：排序后的Excel文件。
- 功能：读取输入的Excel文件，按照指定的字段值对数据进行排序（升序或降序），并生成一个新的Excel文件，包含排序后的数据。

> 举例：读取“面试打分表.xlsx”，按照“归一化成绩”字段进行降序排序，生成一个新的Excel文件，包含排序后的数据（内容不变，只是顺序调换）。

#### 程序六：表格合并程序

- 输入：多个Excel文件（字段值完全相同）
- 输出：合并后的Excel文件。
- 功能：读取多个Excel文件，将它们的内容合并到一个新的Excel文件中。合并时对于完全重复的行只保留一行，并生成一个记录所有重复行信息的日志文件。

> 举例：读取多个“面试打分表.xlsx”文件，将它们的内容合并到一个新的Excel文件中，生成一个包含所有面试打分记录的统一表格。

#### 程序七：表格拆分程序

- 输入：一个Excel文件和拆分字段值。
- 输出：多个拆分后的Excel文件。
- 功能：读取输入的Excel文件，按照指定的拆分字段值，将数据拆分成多个新的Excel文件。每个新文件包含相同拆分字段值的行。且新文件的命名格式为“拆分字段的值.xlsx”。

> 举例：读取“总表.xlsx”，按照“小组号”字段进行拆分，生成多个新的Excel文件，“1.xlsx”、“2.xlsx”等，每个文件包含对应小组号的所有志愿者信息。

#### 程序八： 表格去重程序

- 输入：一个Excel文件和需要去重的字段值列表。
- 输出：去重后的Excel文件和重复记录的Excel文件。
- 功能：读取输入的Excel文件，针对指定的字段值进行去重，找出重复的记录，并生成一个新的Excel文件，包含去重后的数据，以及一个新的Excel文件，包含所有重复的记录。

> 举例：读取“志愿者名单.xlsx”，针对“学号”和“姓名”字段进行去重，生成一个新的Excel文件，包含去重后的数据，以及一个新的Excel文件，包含所有重复的记录。

注意：上面程序中所有生成的新文件的路径和文件名都可以自定义设置。（可通过参数传递，如果没有参数，就使用默认路径和默认文件名）

### 面试结果收集模块

#### 程序一：面试打分表汇总程序

- 输入：多个面试打分表的Excel文件。
- 输出：统一的面试打分表Excel文件。
- 功能：读取多个面试打分表，提取必要信息（“姓名”，“学号”，“归一化成绩”，“小闪电得分”，“摄影得分”），合并为一个统一的表格，并根据“归一化成绩”进行全部面试人员排序（顺序为分数从高到低排布）。合并后的面试结果汇总表总共有五列，分别是“姓名”，“学号”，“归一化成绩”，“小闪电得分”和“摄影得分”。但对于很多人来说，“小闪电得分”和“摄影得分”可能是空值，因为并不是所有人都报名参加了“小闪电”或“摄影志愿者”。

> 这里可以调用通用工具模块中的“表格字段值提取及重命名程序”、“表格合并程序”和“表格排序程序”来实现。

#### 程序二：未面试人员分离程序

- 输入：普通志愿者招募Excel文件和统一的面试打分表Excel文件。
- 输出：未面试人员Excel文件和已面试人员Excel文件。
- 功能：对比普通志愿者招募表和统一面试打分表，找出未参加面试的志愿者，将其信息单独列出，并生成两个新的Excel文件。
- 注意：未面试人员表格和已面试人员表格的字段值和原先的普通志愿者招募表格保持一致。已面试人员表格记为“普通志愿者表”，用于后续的排表流程。

> 这里可以调用通用工具模块中的“表格对比及拆分程序”来实现。

### 排表模块

这是整个系统的核心模块，但为了系统的容错性和灵活性，我们并没有选择将排表模块设计成一个单一的程序，而是将其拆分成多个子程序，每个子程序负责排表流程中的一个或几个环节。通过生成中间文件的方式，将各个子程序串联起来，最终完成整个排表流程。也便于人工介入和调整。

#### 程序一：基本信息核查和收集程序

这一步是排表的预处理环节，这一环节里面会读取大多数的原始表格材料，一共有两个主要功能：信息核查和元数据收集。

- 输入：普通志愿者表Excel文件、内部志愿者表Excel文件、家属志愿者表Excel文件、所有团体志愿者表Excel文件、情侣志愿者表Excel文件、岗位表Excel文件、直接委派名单Excel文件。
- 输出：重复记录核查结果报告和情侣志愿者资格核查结果报告
- 功能一（信息核查）：针对输入的四个志愿者表格，针对“学号”和“姓名”字段进行查重，找出多个表格中这两个字段值重复的记录，并生成查重结果报告，包含重复学号和姓名的详情信息以及所有重复的文件信息。
  > 这里可以调用通用工具模块中的“多表格查重程序”来实现。
  >
- 功能二（元数据收集）：统计并收集以下元数据信息，生成一个json文件“metadata.json”，相当于一些基本或重要信息的缓存，供后续的排表程序调用和人工查看。
  - 内部志愿者中报名组长的人数 L 。
  - 岗位数量 P 。
  - 各岗位的需求人数列表（岗位名称-需求人数的键值对）。
  - 普通志愿者表中的总人数 T 。
  - 正式普通志愿者表中的总人数 M 。
  - 储备志愿者表中的总人数 S 。
  - 内部志愿者表中的总人数 I 。
  - 家属志愿者表中的总人数 F 。
  - 团体志愿者表中的总人数 G 。
  - 各个团体的团体名及对应的人数列表（团体名称-人数的键值对）。
  - 情侣志愿者表中的总人数 C 。
  - 直接委派名单中的总人数 D 。

#### 程序二：正式普通志愿者和储备志愿者拆分程序

- 输入：普通志愿者表Excel文件，metadata.json文件，面试汇总表Excel文件。
- 输出：正式普通志愿者表Excel文件和储备志愿者表Excel文件。
- 功能：根据metadata.json文件中的正式普通志愿者总人数 M ，将普通志愿者表拆分成两张表：一张是需要分配的"正式普通志愿者表"（面试汇总表中归一化成绩排序的前 M 名），另一张是"储备志愿者表"（后面的人员）。储备志愿者表要按照面试汇总表的归一化成绩从高到低排列，方便后续管理和跟进。

#### 程序三：家属志愿者资格审查程序

- 输入：家属志愿者表Excel文件；指定的每个内部人员可以携带的家属人数上限（默认为2）。
- 输出：家属志愿者资格审查结果报告。
- 功能：检查“你是谁的家属”这一字段值对应的姓名在家属志愿者表中是否重复出现超过指定的上限。如果超过上限，则说明该内部人员携带的家属人数超过了上限，生成资格审查结果报告，列出所有超过上限的内部人员及其携带的家属名单和原因。 后续我们会根据报告，人工删除掉家属志愿者表中超过上限的家属记录，确保后续排表时只考虑符合资格的家属志愿者。
  > 举例：如果内部志愿者张三有三个家属报名参加家属志愿者，那么就说明张三携带的家属人数超过了上限2人，报告中列出张三的姓名和这三个家属的详细信息及原因。
  >

#### 程序四：情侣志愿者资格核查程序

- 输入：情侣志愿者表Excel文件、正式普通志愿者表Excel文件、内部志愿者表Excel文件、家属志愿者表Excel文件、所有团体志愿者表Excel文件。
- 输出：情侣志愿者资格核查结果报告。
- 功能：针对情侣志愿者表中的每一对情侣，检查他们是否都在上述四个志愿者表格中出现。如果有一方不在任何一个表格中出现，则说明该对情侣不符合资格，生成资格核查结果报告，列出所有不符合资格的情侣名单及原因。 后续我们会根据报告，人工删除掉情侣志愿者表中不符合资格的情侣记录，确保后续排表时只考虑符合资格的情侣志愿者。
  > 举例：情侣一学号“2025001”存在于正式普通志愿者表中，情侣二学号“2026001”不存在于任何一个志愿者表中，则说明该对情侣不符合资格，报告中列出该对情侣的详细信息及原因。（这里有可能有情侣出现在储备志愿者表中，但储备志愿者不参与排表，所以也视为不符合资格。）
  >

#### 程序五：小组划分及组长分配程序

- 输入：metadata.json、岗位表Excel文件和内部志愿者表Excel文件。
- 输出：小组划分及组长分配结果Excel文件（小组信息表Excel文件）。
- 功能：根据岗位需求和内部志愿者报名组长的人数，划分出总表的小组，并分配组长。生成一个新的Excel文件，起名叫“小组信息表”，包含每个小组的岗位名称、岗位简介、小组号、组长姓名、组长学号，组长手机号，小组人数等信息。

> - 这是排表的第一步，分配过程需要一个合理的算法，确保小组人数均衡，且报名组长的内部志愿者尽可能都能当上组长。
> - 小组信息表生成之后，可以人工查看和调整，确保每个小组的组长分配合理。后面的排表流程会基于这个小组信息表进行。

#### 程序六：绑定集合生成程序

- 输入：情侣志愿者表Excel文件、家属志愿者表Excel文件、所有团体志愿者表Excel文件和直接委派名单Excel文件。
- 输出：绑定集合Excel文件，绑定集合汇总报告（可以是文本文件）。
- 功能：根据输入的三个表格，生成绑定集合，确保在排表时绑定关系能够被满足。生成一个新的Excel文件，起名叫“绑定集合表”，包含每个绑定集合的成员信息，每个绑定集合用一个唯一的ID进行标识。同时要结合直接委派名单，一个集合中只要有一个成员被直接委派到指定小组，那么整个绑定集合都要被直接委派到该小组，并将集合内所有成员的“目标小组”这一字段值设置为该小组号。如果绑定集合中没有任何成员被直接委派，则该绑定集合的“目标小组”字段值为空，表示该集合未被直接委派，可以在后续排表时自由进行分配。

> 最重要的是要确保绑定集合中的成员不会出现在直接委派名单中被分配到不同的小组的情况。如果出现这种冲突情况，要及时在绑定集合报告中填写相应的错误信息，方便人工处理。
>
> - 绑定集合Excel文件包含以下字段值：
> - 绑定集合ID
> - 成员学号
> - 成员姓名
> - 目标小组（如果该成员所在的绑定集合被直接委派到指定小组，则填写该小组号，否则为空）
>
>> 相同绑定集合ID的成员属于同一个绑定集合。
>>
>
> - 绑定集合报告汇总包含以下信息：
> - 绑定集合总数
> - 所有绑定集合的详细信息。每一行记录一个绑定集合，包含绑定集合ID和成员名单（只有姓名）。
> - 绑定集合成员总数分布统计。比如有多少个绑定集合包含2人，多少个绑定集合包含3人，依此类推。
> - 绑定集合ID与目标小组的对应关系统计。列出所有被直接委派到指定小组的绑定集合ID及其对应的小组号。
> - 如果出现绑定集合成员在直接委派名单中被分配到不同小组的冲突情况，则列出所有冲突的绑定集合ID及其成员详情，方便人工处理。

- 绑定步骤：

1. 情侣志愿者绑定：根据情侣志愿者表，将报名的情侣志愿者进行绑定，确保他们在排表时被安排在同一小组工作。每对情侣形成一个绑定集合。
2. 家属志愿者绑定：根据家属志愿者表，如果家属志愿者希望和对应的内部志愿者同组工作(且对应的内部人员姓名出现在了内部志愿者名单中)，则将他们进行绑定，确保他们在排表时被安排在同一小组工作。每个家属志愿者和对应的内部志愿者形成一个绑定集合。因为家属志愿者表中只有对应内部志愿者的姓名信息，在这里可能还需要读取内部志愿者表，获取内部志愿者的学号信息。
3. 团体志愿者绑定：根据团体志愿者表，将同一团体的志愿者进行绑定，确保他们在排表时被安排在同一小组工作。每个团体的所有成员形成一个绑定集合。
4. 绑定集合合并：检查是否有绑定元素重合的情况，如果有，则将这些绑定集合进行合并，确保同一个绑定集合的所有成员都被正确包含在内。
5. 确定绑定集合的直接委派关系：检查绑定集合中的成员有没有出现在直接委派名单中，集合中只要有一个成员要委派到指定小组，那么整个集合都要被委派到该小组。所以不允许出现同一个绑定集合中的不同成员被委派到不同小组的情况。如果出现这种冲突情况，要及时报错并人工处理。

#### 程序六：排表主程序

这个程序是排表模块的核心程序，负责将所有志愿者分配到各个小组中，生成最终的排班总表。这里需要实现前面“排表规则”部分中提到的各个环节和规则，确保排表过程合理且符合要求。

- 输入：小组信息表Excel文件、绑定集合表Excel文件、正式普通志愿者表Excel文件、内部志愿者表Excel文件、家属志愿者表Excel文件、所有团体志愿者表Excel文件、metadata.json文件、直接委派名单Excel文件。
- 输出：总表Excel文件。
- 功能：根据岗位需求和志愿者的属性，将志愿者分配到各个小组中，生成最终的排班总表。确保所有岗位的需求人数都被满足，且所有绑定关系都被满足。总表中会包含每个志愿者的基本信息和所属小组信息，并根据志愿者的属性和身份的不同，设置不同的背景颜色。

> 设置背景颜色要遵循优先级规则，大体上原则是“身份 > 属性”。即在设置背景颜色时要先考虑志愿者的身份（组长、小闪电、摄影、情侣，只有这四种），如果没有任何身份，则再考虑属性（内部志愿者、家属志愿者、团体志愿者）。如果一个志愿者同时具有多种身份，则按照优先级最高的身份来设置背景颜色。优先级顺序为：组长 > 小闪电 > 摄影 > 情侣 。比如某个志愿者的属性是“家属志愿者”，但他同时拥有情侣和小闪电的身份，那么他最终的背景颜色应该是小闪电的颜色，因为小闪电的优先级高于情侣和家属志愿者。

#### 程序七：总表拆分程序

- 输入：总表Excel文件。
- 输出：多个小组拆分后的Excel文件。
- 功能：读取总表Excel文件，按照“小组号”字段进行拆分，生成多个新的Excel文件。每个新文件包含相同小组号的行。且新文件的命名格式为“<小组号>.xlsx”。但注意：拆分后的小组文件中不含“证件类型”和“证件号”这两个字段值，以保护志愿者的隐私；且不包含背景颜色信息，只有纯数据，方便打印和分发给各个小组成员使用。

> 这里可以调用通用工具模块中的“表格拆分程序”来实现。

#### 程序八：表格整合程序

这个程序的作用是利用Excel表格的多sheet特性，将重要的相关表格整合到一个Excel文件中，方便查看和管理。

- 输入：总表Excel文件、小组信息表Excel文件、储备志愿者表Excel文件、metadata.json文件。
- 输出：整合后的Excel文件（为方便区分，这个表记作“大总表”）
- 功能：将输入的四个文件整合到一个新的Excel文件中，分别作为不同的sheet进行存放。生成一个新的Excel文件，起名叫“大总表”，包含以下四个sheet：
  - 总表sheet：包含总表的内容，和原先的总表内容完全一致。
  - 小组信息表sheet：包含小组信息表的内容，和原先的小组信息表内容完全一致。
  - 储备志愿者表sheet：包含储备志愿者表的内容，和原先的储备志愿者表内容完全一致。
  - 颜色对照表sheet：根据metadata.json文件中的颜色配置项，生成一个颜色对照表，列出每种志愿者身份或属性对应的背景颜色值，方便查看和管理。

## 整体文件架构与设计方案

项目采用“关注点分离”的原则进行目录组织，将数据、源代码、配置、日志等不同职责的文件物理隔离，形成清晰、直观、可扩展的结构。

### 项目文件树

```
志愿者排表系统/
├── input/                            # 存放所有原始、不变的输入数据 (只读)
│   ├── 团体/
│   │   ├── 计算机学院团委.xlsx
│   │   └── ...
│   ├── 面试打分表/
│   │   ├── 面试官A.xlsx
│   │   └── ...
│   ├── 普通志愿者招募表.xlsx
│   ├── 内部志愿者表.xlsx
│   ├── 家属志愿者表.xlsx
│   ├── 情侣志愿者表.xlsx
│   ├── 岗位表.xlsx
│   └── 直接委派名单.xlsx
│
├── pipeline/                         # 数据处理流水线的“工作空间”，存放所有中间数据产物
│   ├── 01_interview_results/         # 面试结果收集模块的输出
│   │   ├── 统一面试打分表.xlsx
│   │   ├── 普通志愿者表.xlsx
│   │   └── 未面试人员名单.xlsx
│   └── 02_scheduling_preparation/    # 排表准备阶段的输出
│       ├── metadata.json
│       ├── 正式普通志愿者表.xlsx
│       ├── 储备志愿者表.xlsx
│       ├── 小组信息表.xlsx
│       └── 绑定集合表.xlsx
│
├── output/                           # 存放最终交付给用户的成果
│   ├── 总表.xlsx
│   ├── 大总表.xlsx
│   └── 各小组名单/
│       ├── 1.xlsx
│       └── ...
│
├── reports/                          # 存放所有给人工审阅的报告文件
│   ├── 多表格查重报告.txt
│   ├── 家属志愿者资格审查结果报告.txt
│   ├── 情侣志愿者资格核查结果报告.txt
│   └── 绑定集合汇总报告.txt
│
├── logs/                             # 存放所有程序的运行日志 (结构与src镜像)
│   ├── utils/
│   │   ├── merger.log
│   │   ├── sorter.log
│   │   ├── extractor.log
│   │   ├── excluder.log
│   │   ├── splitter.log
│   │   ├── comparator.log
│   │   ├── deduplicator.log
│   │   ├── joiner.log
│   │   └── ...
│   ├── interview/
│   │   ├── summarizer.log
│   │   └── separator.log
│   └── scheduling/
│       ├── pre_checker.log
│       ├── splitter.log
│       ├── family_checker.log
│       ├── couple_checker.log
│       ├── group_allocator.log
│       ├── binder.log
│       ├── main_scheduler.log
│       └── finalizer.log
│
├── src/                              # 存放所有Python源代码
│   ├── __init__.py
│   ├── utils/                        # 通用工具模块
│   │   ├── __init__.py
│   │   ├── _excel_handler.py
│   │   ├── logger_factory.py
│   │   ├── merger.py
│   │   ├── sorter.py
│   │   ├── extractor.py
│   │   ├── excluder.py
│   │   ├── splitter.py
│   │   ├── comparator.py
│   │   ├── deduplicator.py
│   │   ├── joiner.py
│   │   └── checker.py
│   ├── interview/                    # 面试结果收集模块
│   │   ├── __init__.py
│   │   ├── summarizer.py
│   │   └── separator.py
│   └── scheduling/                   # 排表模块
│       ├── __init__.py
│       ├── data_models.py
│       ├── pre_checker.py
│       ├── splitter.py
│       ├── family_checker.py
│       ├── couple_checker.py
│       ├── group_allocator.py
│       ├── binder.py
│       ├── main_scheduler.py
│       └── finalizer.py
│
├── config/                           # 存放配置文件
│   ├── __init__.py
│   ├── config.yaml
│   └── loader.py
│
├── main.py                           # 主控程序，整个流程的入口
├── Makefile                          # 命令行快捷方式
├── requirements.txt                  # 项目依赖库列表
├── .gitignore                        # Git忽略文件配置
└── README.md                         # 项目说明文档
```

### 目录职责说明

* **`input/`, `pipeline/`, `output/`, `reports/`**: 分别承担**数据源、加工中转、成果交付、人工决策支持**的职责，形成一条清晰的数据处理链路。
* **`logs/`**: **问题追溯与调试中心**，为每个程序模块提供独立的日志记录，完美支持分步执行和调试的工作模式。
* **`src/`**: **项目大脑**，其内部的 `utils`, `interview`, `scheduling` 子目录精确映射了项目的三大核心业务模块。
* **`config/`**: **项目神经中枢**，通过一个组织良好的 `config.yaml` 文件，实现代码与配置的完全分离。

### 配置文件设计方案 (`config/`)

采用**增强版的单一文件**方案，在保持简洁性的同时，通过文件内的逻辑分组和丰富注释，实现高度的结构化和可读性。

* **核心思想**：所有配置项集中于一个 `config.yaml` 文件，但内部通过一级键（如 `paths`, `files`, `settings`）进行清晰的逻辑分段。
* **配置内容**：

  * **路径配置** (`paths`)：定义所有关键目录和文件的绝对或相对路径。
  * **文件名配置** (`files`)：定义所有输出文件的命名规则和格式。
  * **算法参数** (`settings`)：定义排表算法中的各种可调参数，如优先级权重、分配策略等。
  * **颜色代码** (`colors`)：定义不同志愿者身份和属性对应的Excel背景颜色代码。根据志愿者种类和身份的不同，在最后总表中对应的背景颜色值。有颜色的志愿者有：内部志愿者、家属志愿者、团体志愿者（每个团体一个颜色）、组长志愿者、情侣志愿者、摄影志愿者、小闪电志愿者。

  > 一般来说普通志愿者（无其他任何身份）不设背景色（无色）。储备志愿者单独成表，不在总表中出现，所以也不设背景色。组长志愿者是黄色，情侣志愿者是粉色，摄影志愿者是淡紫色，小闪电志愿者是绿色。家属志愿者和内部志愿者可以是蓝色和橙色。团体志愿者的颜色可以从一组预设颜色中依次分配。
  >
* **技术实现**：

  * 选用 **YAML** 格式，以获得最佳的可读性和注释支持。
  * `loader.py` 模块负责加载 `config.yaml`，并处理路径变量的引用替换，向上层代码提供一个简洁的、全局唯一的配置对象 `CONFIG`。
* **系统作用**：

  * **解耦与中心化**：将所有可变参数（路径、文件名、算法参数、颜色代码等）从代码中剥离，集中管理，极大地提升了项目的灵活性和可维护性。

### 日志系统设计方案 (`logs/`)

根据项目**以人工分步执行为主，单步调试需求高**的实际使用模式，日志系统采用**目录结构与源代码 (`src`) 镜像**的方案。

* **核心思想**：为每个可执行的程序模块创建独立的、路径镜像的日志文件，以提供最精准、最无干扰的调试环境。
* **技术实现**：
  * 在 `src/utils/` 中创建 `logger_factory.py` 模块，提供 `get_logger(__file__)` 函数。
  * 该函数能根据调用方文件的路径，自动创建并配置一个指向正确镜像日志文件的 logger 实例。
* **系统作用**：
  * **精准追溯**与**调试友好**，完美契合“手动执行一步，检查一步日志”的工作模式。

### 通用工具模块 (`utils`) 设计方案

此模块被设计为一个**可复用的、独立的Excel处理工具箱**，其功能与 `通用工具模块` 中定义的九大程序完全对应。

* **核心思想**：“核心逻辑类 + 命令行接口包装器”的设计模式。
* **架构**：
  * **`_excel_handler.py`**: 封装一个 `ExcelHandler` 类，实现所有底层的、基于 Pandas 的Excel操作，作为可被项目内其他模块直接调用的 **API**。
  * **独立的包装器脚本** (如 `merger.py`, `joiner.py`): 每一个脚本都是一个独立的**命令行工具 (CLI)**，负责解析命令行参数并调用 `ExcelHandler` 的相应方法。
* **系统作用**：
  * 实现了**代码复用**，并提供了**命令行**和**函数库**两种使用方式，兼具独立性和集成性。

### 面试结果收集模块 (`interview`) 设计方案

此模块是数据流入系统的第一个加工站，负责**数据清洗与准备**。

* **核心思想**：通过 `summarizer.py`（汇总）和 `separator.py`（分离）两个独立的程序，将分散、非标准的原始数据，转化为后续流程所需的、结构统一的核心输入。
* **系统作用**：承上启下，为后续的“排表模块”提供干净、可靠、结构化的志愿者名单。

### 排表模块 (`scheduling`) 设计方案

此模块是整个系统的**核心业务引擎**，其最终设计方案融合了严谨的逻辑流程和清晰的数据模型，并完全适配最新版 `README.md` 的所有规则。

* **核心思想**：将复杂的排班任务分解为一系列职责单一的子程序，并通过一个**严格的多阶段、优先级驱动**的算法来执行分配。
* **关键设计点**：

  1. **`data_models.py`**: 定义 `Volunteer`, `Group`, `BindingSet` 等数据类，并在 `Group` 中增加 `has_lightning` 等状态追踪标志，为复杂的分配逻辑提供清晰的数据载体。
  2. **新增预处理步骤**: 模块流程中新增 `family_checker.py` 程序，负责在家属绑定前进行资格审查，确保内部人员携带家属数量不超过上限。
  3. **规则精化实现**:
     * `binder.py` 在执行家属绑定时，会校验内部志愿者姓名的有效性，对于无效绑定按独立志愿者处理。
     * `main_scheduler.py` 在填充“小闪电”和“摄影”身份时，其候选人范围将**严格限定**于尚未分配的“正式普通志愿者”。
  4. **`binder.py` (规则预处理器)**: 在生成绑定集合后，**立即与“直接委派名单”进行交叉验证**，为需要委派的集合打上“目标小组”标记，并**前置所有潜在的分配冲突检测**，生成详细报告。
  5. **`main_scheduler.py` (核心分配引擎)**: 其算法严格遵循 `README.md` 最新定义的**“先整体后个体，先委派后自由”**原则，按以下多阶段流程执行：
     * **阶段〇：初始化与人员池分离**: 将所有志愿者预先区分为“绑定池”和“独立池”。
     * **阶段一：框架搭建与组长分配**: 搭建小组框架，并处理最高优先级的组长及其绑定关系。
     * **阶段二：绑定集合分配**: 严格区分并优先处理“直接委派的”绑定集合，再处理“自由分配的”绑定集合。
     * **阶段三：独立志愿者分配**: 优先处理被直接委派的落单志愿者，再处理剩余的内部和家属志愿者。
     * **阶段四：特殊身份填充**: 检查并为缺少特殊身份的小组，从剩余的正式普通志愿者中择优补充。
     * **阶段五：最终填充**: 用所有剩余的正式普通志愿者填满所有岗位。
  6. **`finalizer.py` (成果打包程序)**: 负责对排班结果进行最后的“精加工”，包括**上色、按小组拆分（移除隐私字段）、整合为大总表**等。
* **系统作用**：通过上述设计，排表模块能够精确、可靠地执行 `project.md` 中定义的每一个细节，特别是完美地实现了“**先处理约束强的，再处理约束弱的**”和“**先处理整体，再处理个体**”的核心算法原则，确保了最终排班结果的正确性和合理性。

## 潜在风险与边界情况

任何自动化系统在与现实世界的数据和操作交互时，都可能遇到预料之外的情况。本章节旨在前瞻性地识别这些潜在风险和边界情况，并阐述本系统所设计的缓解策略。其核心设计思想是**“快速失败，清晰报告，支持人工决策”**。

### 数据输入与质量风险

这是最常见的风险来源。原始输入表格的任何不规范都可能影响流程。

* **风险 1: 关键信息冲突（跨表重复）**

  * **风险描述**: 同一个志愿者（以“学号”为唯一标识）出现在了多个互斥的来源表中。例如，张三既在 `内部志愿者表.xlsx` 中，又在 `普通志愿者招募表.xlsx` 中。这违反了志愿者属性互斥的基本原则。
  * **缓解策略**: `scheduling/pre_checker.py` 程序被设计为流水线的“看门人”。它会首先对所有志愿者来源表进行交叉查重，并将所有冲突的记录详细输出到 `reports/多表格查重报告.txt` 中。用户必须在解决这些数据源冲突后，才能继续执行后续流程。
* **风险 2: 无效引用（悬空指针）**

  * **风险描述**: 存在引用关系，但被引用的实体不存在。主要有两种情况：
    1. `情侣志愿者表.xlsx` 中的某位成员，其学号不存在于任何一个最终的正式志愿者名单中（例如，该成员未通过面试，成为了储备志愿者或未面试人员）。
    2. `家属志愿者表.xlsx` 中，某家属希望绑定的内部志愿者姓名，在 `内部志愿者表.xlsx` 中找不到（可能由于笔误或该内部人员未报名）。
  * **缓解策略**:
    1. `scheduling/couple_checker.py` 程序专门负责此项检查，会将所有不合格的情侣组合输出到 `reports/情侣志愿者资格核查结果报告.txt`，并提示用户基于此报告清理原始表格。
    2. `scheduling/binder.py` 程序在处理家属绑定时，会校验内部志愿者姓名的有效性。对于无效的引用，系统会记录日志并**自动将其视为绑定失败**，该家属将按独立的、落单的志愿者参与后续分配，确保流程不会因此中断。
* **风险 3: 列名不一致**

  * **风险描述**: 不同的输入表格中，表示相同含义的列，其表头名称不完全一致。例如，“学号”在一张表中叫“学号”，在另一张表中叫“我的学号”。
  * **缓解策略**: 系统不依赖于写死的精确列名。在 `config/config.yaml` 中，我们为所有关键字段（学号、姓名、归一化成绩等）定义了**关键字**。程序在读取Excel时，会通过“包含关键字”的方式来动态识别列，这极大地增强了对不同表格格式的适应性。

### 算法与逻辑风险

当输入数据本身没有问题，但数据的组合触发了规则的逻辑冲突时，会产生此类风险。

* **风险 4: 绑定集合内的委派冲突 (最严重的逻辑冲突)**

  * **风险描述**: 同一个绑定集合（例如，一个团体或一对情侣）中的不同成员，在 `直接委派名单.xlsx` 中被分配到了不同的小组。这在逻辑上是矛盾的，因为整个集合必须被分配到同一个小组。
  * **缓解策略**: 这是系统的**硬性校验点**。`scheduling/binder.py` 程序在生成绑定集合后，会立即进行委派交叉验证。一旦发现此类冲突，它会**终止流程的正常进行**，并将冲突的详细信息（哪个集合、哪些成员、被分配到了哪些不同的小组）醒目地记录在 `reports/绑定集合汇总报告.txt` 的“冲突报告”部分。**此问题必须由人工介入解决**（修改 `直接委派名单.xlsx`），否则排表无法继续。
* **风险 5: 绑定集合超出所有小组剩余容量**

  * **风险描述**: 在自由分配阶段，一个较大的绑定集合（例如一个15人的团体）需要被分配，但此时所有小组的剩余空位都小于15。
  * **缓解策略**: 系统的 `main_scheduler.py` 采用了“大集合优先”的贪心算法，这在大多数情况下可以避免此问题。但若该问题依然发生，该绑定集合将无法被分配。系统不会报错，但最终生成的 `总表.xlsx` 将缺少这个集合的成员，且总人数会少于岗位需求总人数。这是一个明确的信号，操作者可以通过对比总人数来发现此问题。**解决方案需要人工介入**，例如在 `小组信息表.xlsx` 中调整某些小组的容量，或者手动拆分这个团体。
* **风险 6: 关键资源不足**

  * **风险描述**:
    1. 报名的组长人数 L 少于岗位总数 P。
    2. 符合条件的“小闪电”或“摄影”志愿者人数，少于需要补充这些身份的小组数量。
  * **缓解策略**:
    1. 对于组长不足的情况，`scheduling/group_allocator.py` 程序会明确报错并**终止执行**，要求人工解决（在内部志愿者中招募更多组长）。
    2. 对于特殊身份不足的情况，系统被设计为**“尽力而为”**。`main_scheduler.py` 会为能够满足条件的小组分配特殊身份志愿者，而无法满足的小组则会空缺。这不会中断流程，最终结果会如实反映在 `总表.xlsx` 中。

### 操作与流程风险

* **风险 7: 未按顺序执行程序**

  * **风险描述**: 用户在手动执行时，跳过了某个步骤或颠倒了顺序（例如，未执行 `binder.py` 就直接执行 `main_scheduler.py`）。
  * **缓解策略**: 本系统的模块化设计是基于**中间文件**进行串联的。如果上一步骤未执行，其本应生成的输入文件（如 `绑定集合表.xlsx`）就不会存在，下一步程序在尝试读取该文件时会立即失败并报错。这种**“快速失败”**机制天然地阻止了错误的执行顺序。使用 `main.py` 主控程序可以完全避免此问题。
* **风险 8: 忽略报告并继续执行**

  * **风险描述**: 系统生成了包含错误的报告（如情侣资格审查报告），但用户没有根据报告去修正原始输入数据，而是继续执行了后续步骤。
  * **缓解策略**: 这是**用户责任**。本系统的设计理念是“系统负责检测和报告，用户负责决策和修正”。系统会基于当前（可能不正确的）输入数据继续执行，这可能导致最终的排班结果不符合预期。项目文档和操作手册必须强调**“先审查报告，后执行后续步骤”**的核心工作流程。
