# 排表主程序详细步骤讲解

## 基本信息

这个程序是排表模块的核心程序（`main_scheduler.py`），负责将所有志愿者分配到各个小组中，生成最终的排班总表。这里需要实现前面“排表规则”部分中提到的各个环节和规则，确保排表过程合理且符合要求。

- **输入**：
  - `pipeline\02_scheduling_preparation\小组信息表.xlsx`
  - `pipeline\02_scheduling_preparation\绑定集合表.xlsx`
  - `pipeline\02_scheduling_preparation\正式普通志愿者表.xlsx`
  - `input\内部志愿者表.xlsx`
  - `input\家属志愿者表.xlsx`
  - `input\团体\` (所有团体表)
  - `pipeline\02_scheduling_preparation\metadata.json`
  - `input\直接委派名单.xlsx`
  - `pipeline\01_interview_results\统一面试打分表.xlsx` (用于特殊身份筛选)
- **输出**：
  - `output\总表.xlsx`
- **功能**：
  - 根据岗位需求和志愿者的属性，将志愿者分配到各个小组中，生成最终的排班总表。
  - 确保所有岗位的需求人数都被满足，且所有绑定关系都被满足。
  - 总表中会包含每个志愿者的基本信息和所属小组信息，并根据志愿者的属性和身份的不同，设置不同的背景颜色。

> **颜色优先级规则**：
> 设置背景颜色遵循“身份 > 属性”原则。
> 优先级顺序为：**组长 > 小闪电 > 摄影 > 情侣**。
> 如果没有任何特殊身份，则考虑属性：**内部志愿者、家属志愿者、团体志愿者**。
> 普通志愿者（无特殊身份）无背景色。

## 核心设计思想：内存对象模型

为了避免直接操作 Excel 导致的索引错位和性能问题，本程序采用**“内存对象模型”**策略。即先在 Python 内存中建立完整的 `Group`（小组）和 `Volunteer`（志愿者）对象关系，完成所有分配逻辑后，最后一次性写入 Excel 文件。

## 详细步骤

### 1. 数据加载与对象初始化

这一步是构建排班“世界观”的基础。

1. **加载配置与元数据**：读取 `config.yaml` 和 `metadata.json`，获取颜色代码、列名关键字等全局配置。
2. **构建小组对象池**：
   - 读取 `小组信息表.xlsx`。
   - 为每一行创建一个 `Group` 对象，包含属性：`group_id`（小组号）、`position_name`（岗位名称）、`capacity`（需求人数）、`members`（成员列表，初始为空）。
   - 建立一个字典 `groups_map = {group_id: Group对象}` 方便后续通过小组号快速查找。
3. **构建志愿者对象池**(可以是字典类型，键是学号，值是Volunteer)：
   - 读取所有来源表格（正式普通、内部、家属、团体）。
   - **数据清洗（宿舍楼栋）**：在读取每一行时，检查“宿舍楼栋（闵行）”字段。如果不为空，将其赋值给“宿舍楼栋”属性；如果为空，则取“宿舍楼栋（非闵行）”的值。
   - **对象创建**：为每个人创建一个 `Volunteer` 对象，存储所有基本信息。
   - **补充赋值情侣身份**：读取情侣志愿者表，将表中的每个人对应的 `Volunteer` 对象都附上情侣身份。
   - **颜色预计算**：根据志愿者的身份（是否组长、情侣等）和配置文件中的优先级，直接计算出该志愿者的 `bg_color`（背景色代码），存入对象属性中。要注意团体志愿者是每个团体一个颜色
   - **全局防重集合**：创建一个集合 `placed_student_ids`，用于存储所有已分配志愿者的学号。任何时候分配一个人，都要先检查是否在此集合中，分配后立即加入此集合。

### 2. 人员分类与池化 (Segregation)

为了支持“先整体后个体，先委派后自由”的算法，需要将人员预先分类放入不同的“池子”。

1. **加载绑定集合**：读取 `绑定集合表.xlsx`。
   - **直接委派绑定池 (`priority_binding_sets`)**：筛选出 `目标小组` 字段**不为空**的绑定集合。
   - **自由分配绑定池 (`free_binding_sets`)**：筛选出 `目标小组` 字段**为空**的绑定集合，并按**集合人数降序**排列（大集合优先原则）。
2. **加载落单志愿者**：
   - 将所有不在任何绑定集合中的志愿者放入 `lone_volunteers_pool`。
   - 并进一步按类型细分为：`lone_internal` (内部)、`lone_ordinary` (普通)。（因为在绑定集合中已经包含了所有的家属志愿者，所以这里的落单志愿者只有内部和）
3. **加载直接委派名单**：
   - 读取 `直接委派名单.xlsx`，生成一个字典 `{学号: 目标小组号}`。

### 3. 核心分配流程 (Assignment Execution)

严格按照以下顺序执行分配，确保高优先级规则先被满足。

#### 阶段一：组长分配 (Skeleton Building)

1. 遍历所有 `Group` 对象，根据小组信息表中的组长信息，找到对应的 `Volunteer` 对象。
2. 将组长加入该 `Group.members`，更新 `placed_student_ids`。
3. **组长绑定处理**：检查组长是否属于某个 `BindingSet`。如果是，将该集合中的其他成员立即分配到同一小组。

#### 阶段二：绑定集合分配 (Binding Sets)

1. **处理直接委派集合**：
   - 遍历 `priority_binding_sets`。
   - 获取每个集合的 `目标小组号`，找到对应的 `Group` 对象。
   - 将集合内所有成员加入该 Group（需检查是否已在阶段一分配过，防止重复）。
2. **处理自由分配集合**：
   - 遍历排序后的 `free_binding_sets`。
   - 为每个集合寻找一个最合适的小组。
   - **筛选条件**：`Group.remaining_capacity >= 集合人数`。
   - **择优策略**：优先选择剩余空位最多的小组，以保持整体均衡。
   - 分配全员并更新状态。

#### 阶段三：直接委派的落单个人 (Direct Individuals)

1. 遍历直接委派名单字典。
2. 对于每个学号，检查是否已在 `placed_student_ids` 中。
3. 如果未分配（说明是落单者），将其直接加入指定的目标 `Group`。

#### 阶段四：剩余内部与家属志愿者 (Remaining Internal/Family)

1. 从 `lone_volunteers_pool` 中取出所有尚未分配的 **内部** 和 **家属** 志愿者。
2. 遍历这些志愿者，依次分配到有剩余空位的小组中。
3. **策略**：可以采用轮询（Round-Robin）或优先填补空位较多的小组，确保分布均匀。

#### 阶段五：特殊身份填充 (Special Roles)

1. **状态盘点**：遍历所有 `Group`，检查现有成员，更新每个小组的 `has_lightning`（已有小闪电）和 `has_photographer`（已有摄影）标志。
2. **小闪电补充**：
   - 找出所有 `has_lightning == False` 且 `remaining_capacity > 0` 的小组。
   - 从 `lone_ordinary`（仅限普通志愿者）中筛选出报名“小闪电”的候选人，按“小闪电归一化成绩”降序排列。
   - 依次将高分候选人分配给缺小闪电的小组，直到所有小组满足或候选人耗尽。
3. **摄影志愿者补充**：
   - 逻辑同上，针对 `has_photographer == False` 的小组，从普通志愿者中按“摄影归一化成绩”择优分配。

#### 阶段六：最终填充 (Final Fill)

1. 获取 `lone_ordinary` 中所有剩余的、尚未分配的 **正式普通志愿者**。
2. 遍历所有 `Group`，只要 `remaining_capacity > 0`，就填入一个志愿者。
3. 继续循环直到所有志愿者被分配完毕。
4. **校验**：此时应确保所有志愿者池为空，且所有小组刚好满员（允许极少数因不可抗力导致的空缺，记录日志）。

### 4. 结果输出 (Output Generation)

所有分配逻辑在内存中完成后，统一写入文件。

1. **构建数据行**：
   - 遍历所有 `Group` 对象。
   - 遍历每个 Group 中的 `members`。
   - 构建每一行数据：`[小组号, 岗位名称, 岗位简介, 组长姓名, 成员学号, 成员姓名, ... 成员其他信息]`。
   - 同时记录该行的背景颜色代码。
2. **写入 Excel**：
   - 使用 pandas 将数据行列表转换为 DataFrame。
   - 保存为 `output\总表.xlsx`。
3. **应用样式 (Finalizer)**：
   - （此步通常在 `finalizer.py` 中完成，但在此说明逻辑）使用 `openpyxl` 打开生成的 Excel，根据记录的背景颜色代码，为每一行设置单元格填充颜色。

### 5. 输出总表详细规范 (Output Specifications)

为了确保后续的 `finalizer.py` 能正确读取并美化表格，`main_scheduler.py` 生成的 `output\总表.xlsx` 必须严格遵守以下格式约定：

#### 5.1. 文件物理结构

- **文件名**：`总表.xlsx`
- **Sheet名称**：`Sheet1` (默认)
- **表头行**：第 1 行
- **数据起始行**：第 2 行
- **单元格格式**：所有单元格均为“文本”或“常规”格式，**严禁合并单元格**。

#### 5.2. 列顺序与定义

总表必须包含以下 **23列**（包含一列用于传递颜色信息的辅助列），顺序不可错乱：

| 序号 | 列名                 | 说明                                             | 数据类型                      |
| :--- | :------------------- | :----------------------------------------------- | :---------------------------- |
| 1    | **小组号**     | 1, 2, 3...                                       | 数字/文本                     |
| 2    | **岗位名称**   | 如：5KM补给站                                    | 文本                          |
| 3    | **岗位简介**   | 如：饮料站                                       | 文本                          |
| 4    | **小组长**     | 小组长的**姓名**                           | 文本                          |
| 5    | **学号**       | 志愿者的学号                                     | **文本** (防科学计数法) |
| 6    | **姓名**       |                                                  | 文本                          |
| 7    | **姓名拼音**   |                                                  | 文本                          |
| 8    | **性别**       |                                                  | 文本                          |
| 9    | **证件类型**   |                                                  | 文本                          |
| 10   | **证件号**     |                                                  | **文本** (防截断)       |
| 11   | **出生日期**   | 建议格式 YYYY-MM-DD                              | 文本/日期                     |
| 12   | **学院**       |                                                  | 文本                          |
| 13   | **身高**       |                                                  | 数字/文本                     |
| 14   | **邮箱**       |                                                  | 文本                          |
| 15   | **手机号**     |                                                  | **文本** (防截断)       |
| 16   | **QQ号**       |                                                  | **文本**                |
| 17   | **微信号**     |                                                  | 文本                          |
| 18   | **政治面貌**   |                                                  | 文本                          |
| 19   | **马拉松次数** |                                                  | 数字                          |
| 20   | **校区**       |                                                  | 文本                          |
| 21   | **宿舍楼栋**   | 合并后的最终楼栋信息                             | 文本                          |
| 22   | **衣服尺码**   |                                                  | 文本                          |
| 23   | **_bg_color**  | **(辅助列)** 颜色的HEX代码 (如 `FFFF00`) | 文本                          |

> **注意**：
>
> 1. **辅助列处理**：第 23 列 `_bg_color` 是 `main_scheduler.py` 计算出的背景色代码。`finalizer.py` 会读取这一列，将颜色应用到整行，**然后删除这一列**。因此，最终交付给用户的表格只有 22 列。
> 2. **长数字保护**：在写入 Excel 时，务必确保 **学号、证件号、手机号、QQ号** 被强制写入为**字符串格式**，防止 Excel 自动将其转换为科学计数法或去除前导零。

#### 5.3. 行排序规则

生成的 Excel 行必须遵循以下排序逻辑，以便于人工查阅：

1. **第一关键字**：`小组号` (升序，1 -> N)
2. **第二关键字**：`角色权重` (组长排在小组的第一行，其他成员随后)

---

### 6. 数据完整性校验 (Self-Check)

程序在保存文件前，应进行以下自检：

1. **总人数校验**：输出的总行数（不含表头）应严格等于 `metadata.json` 中记录的 `岗位需求总人数`。
2. **ID 唯一性校验**：`学号` 列不应有重复值。
3. **小组完整性校验**：根据 `小组信息表`，检查每个小组的实际分配人数是否等于其 `需求人数`。
4. **空值校验**：除了允许为空的备注类字段，关键字段（学号、姓名、小组号）不应为空。

### 补充修订内容 (Addendum)

为了确保程序的健壮性和输出规范，以下两点在开发时需严格执行：

#### 1. 输入阶段：列名模糊匹配机制 (Fuzzy Column Matching)

在 **“步骤 1：数据加载与对象化”** 中，程序读取 Excel 表格时，**严禁使用硬编码的列名**（如直接代码中写死 `df['学号']`）。必须实现一套模糊匹配逻辑，以应对问卷导出的表头变化。

- **逻辑描述**：
  1. 程序加载 `config.yaml` 中的 `keywords` 配置（例如：`student_id: "学号"`）。
  2. 读取 Excel 文件的所有表头（Columns）。
  3. 对于每一个目标字段（如“学号”），遍历 Excel 的实际表头。
  4. **匹配规则**：如果 `目标关键字` 包含在 `实际表头字符串` 中，则视为匹配成功。
  5. **示例**：
     - 目标关键字：`"学号"`
     - 实际表头：`"您的学号"` -> **匹配成功**
     - 实际表头：`"填报人学号"` -> **匹配成功**
     - 实际表头：`"姓名"` -> **匹配失败**
- **优先级处理**：如果一个关键字匹配到了多个列（例如“电话”匹配到了“手机电话”和“固定电话”），优先选择匹配度更高（长度更短或完全相等）的列，或在日志中输出警告。

#### 2. 输出阶段：组长置顶规则 (Leader-First Sorting)

在 **“步骤 4：结果输出”** 及 **“5.3 行排序规则”** 中，必须严格保证每个小组的第一行数据是组长。
